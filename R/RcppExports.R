# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title
#' b_spline
#'
#' @description
#' Calculate the basis splines
#'
#' @inheritParams splines::bs
#' @param knots location of knots for the b-splines. Unlike `splines::bs` this
#' includes the boundary knots. (numeric vector)
#'
#'
#' @return the basis spline values with intercept.
#'
#' @noRd
#'
b_spline <- function(x, knots, degree) {
    .Call(`_hydrorecipes_b_spline`, x, knots, degree)
}

#' @title
#' fft_matrix
#'
#' @description
#' Do an FFT for each matrix column
#'
#' @param x the matrix that holds the series (numeric matrix)
#' @param detrend remove the linear trend of the columns (boolean)
#' @param demean remove the mean for each column (boolean)
#' @param n_new the padded size (integer)
#'
#' @return A matrix with FFT results.
#'
#' @noRd
#'
fft_matrix <- function(x, n_new) {
    .Call(`_hydrorecipes_fft_matrix`, x, n_new)
}

#' @title
#' convolve_vec
#'
#' @description
#' Circular convolution of two vectors having the same length
#'
#' @param x the vector that holds the series (numeric vector)
#' @param y the vector to convolve with x (numeric vector)
#'
#'
#' @return numeric vector that is the circular convolution of two vectors
#'
#'
#' @noRd
#'
convolve_vec <- function(x, y) {
    .Call(`_hydrorecipes_convolve_vec`, x, y)
}

#' @title
#' convolve_filter
#'
#' @description
#' convolution of vector with matrix
#'
#' @param x vector to convolve with y (numeric vector)
#' @param y numeric matrix to convolve with x (column by column convolution)
#'  (numeric matrix)
#' @param remove_partial keep the end values or fill with NA (boolean)
#' @param reverse should x be reversed before convolution (boolean)
#'
#' @return numeric matrix of convolved values
#'
#' @export
#'
#' @importFrom Rcpp sourceCpp
#' @importFrom stats nextn
#' @importFrom stats convolve
#' @importFrom stats spec.pgram
#'
#' @examples
#' a <- convolve_filter(x = 1:100,
#'                      y = c(1:10, rep(0, 90)),
#'                      remove_partial = FALSE,
#'                      reverse = TRUE)
#'
#' b <- stats::convolve(1:100, rev(1:10), type = 'filter')
#'
convolve_filter <- function(x, y, remove_partial, reverse) {
    .Call(`_hydrorecipes_convolve_filter`, x, y, remove_partial, reverse)
}

#' @title
#' convolve_overlap_add
#'
#' @description
#' Multiply a transfer function with a real input and take the inverse FFT.
#'
#' @param x the vector that holds the series (numeric vector)
#' @param y the kernel to convolve with x (complex numeric vector)
#'
#'
#' @return the linear convolution of two vectors
#'
#' @noRd
#'
convolve_overlap_add <- function(x, y) {
    .Call(`_hydrorecipes_convolve_overlap_add`, x, y)
}

#' @title
#' convolve_overlap_save
#'
#' @description
#' Multiply a transfer function with a real input and take the inverse FFT.
#'
#' @param x the vector that holds the series (numeric vector)
#' @param y the kernel to convolve with x (complex numeric vector)
#'
#'
#' @return the linear convolution of two vectors
#'
#' @noRd
#'
convolve_overlap_save <- function(x, y) {
    .Call(`_hydrorecipes_convolve_overlap_save`, x, y)
}

#' @title
#' convolve_tf
#'
#' @description
#' Multiply a transfer function with a real input and take the inverse FFT.
#'
#' @param x the vector that holds the series (numeric vector)
#' @param y the transfer function to multiply with x (complex numeric vector)
#'
#'
#' @return the circular convolution of two vectors
#'
#' @noRd
#'
convolve_tf <- function(x, y) {
    .Call(`_hydrorecipes_convolve_tf`, x, y)
}

#' @title
#' convolve_matrix
#'
#' @description
#' convolution of vector with matrix
#'
#' @param x vector to convolve with y (numeric vector)
#' @param y numeric matrix to convolve with x (column by column convolution)
#'  (numeric matrix)
#' @param remove_partial keep the end values or fill with NA (boolean)
#' @param reverse should x be reversed before convolution (boolean)
#'
#' @return numeric matrix of convolved values
#'
#' @export
#'
#' @importFrom Rcpp sourceCpp
#' @importFrom stats nextn
#' @importFrom stats convolve
#' @importFrom stats spec.pgram
#'
#' @examples
#' a <- convolve_matrix(x = 1:100,
#'                      y = as.matrix(1:10),
#'                      remove_partial = FALSE,
#'                      reverse = TRUE)
#'
#' b <- stats::convolve(1:100, rev(1:10), type = 'filter')
#'
convolve_matrix <- function(x, y, remove_partial, reverse) {
    .Call(`_hydrorecipes_convolve_matrix`, x, y, remove_partial, reverse)
}

#' @title
#' multiply_ffts
#'
#' @description
#' Multiply each column of a complex matrix with all the columns.
#'
#' @param x complex matrix to convolve with itself (complex numeric matrix)
#' @param n_col number of columns in the original input series (integer)
#' @param truncated skip the first row to decrease memory use? (boolean)
#'
#'
#' @return pgram of input FFT values.
#'
#' @noRd
#'
multiply_ffts <- function(x) {
    .Call(`_hydrorecipes_multiply_ffts`, x)
}

#' @title
#' fill_lower_left
#'
#' @description
#' Fill in the complex conjugate columns.
#'
#' @param x complex matrix of pgram values (complex matrix)
#' @param n_col number of columns in the original input series (integer)
#' @param start the first row index to begin on (boolean)
#'
#'
#' @return Matrix with filled in complex conjugate columns.
#'
#' @noRd
#'
fill_lower_left <- function(x, start) {
    .Call(`_hydrorecipes_fill_lower_left`, x, start)
}

#' @title
#' spec_pgram
#'
#' @description
#' Calculate the periodogram.  This method only keeps the columns necessary for
#' the transfer function calculation. This method is based on `spec.pgram`.
#'
#' @inheritParams spec.pgram
#'
#'
#' @return periodogram from an input matrix using a Fast Fourier Transform.
#' Similar to `spec.pgram` but should be faster.
#'
#' @noRd
#'
spec_pgram <- function(x, spans, detrend, demean, taper) {
    .Call(`_hydrorecipes_spec_pgram`, x, spans, detrend, demean, taper)
}

#' @title
#' spec_welch
#'
#' @description
#' Calculate the periodogram using Welch's method.  This method only keeps the
#' columns necessary for the transfer function calculation. This method is
#' based on `spec.pgram`.
#'
#' @inheritParams spec.pgram
#' @param length_subset length of each subset (integer)
#' @param overlap percent to overlap subsets (double)
#' @param window vector of length length_subset (numeric vector)
#'
#'
#' @return periodogram from an input matrix using a Fast Fourier Transform and
#' Welch's method.
#'
#' @noRd
#'
spec_welch <- function(x, length_subset, overlap, window) {
    .Call(`_hydrorecipes_spec_welch`, x, length_subset, overlap, window)
}

#' @title
#' solve_cplx_parallel
#'
#' @description
#' Calculate the transfer function from a periodogram.
#'
#' @inheritParams spec.pgram
#' @inheritParams make_groups
#'
#' @return the transfer functions.
#'
#' @noRd
#'
solve_cplx_parallel <- function(x) {
    .Call(`_hydrorecipes_solve_cplx_parallel`, x)
}

#' @title
#' solve_cplx_irr
#'
#' @description
#' Calculate the transfer function from a periodogram with irregular sized
#' groups. This is experimental to see if we can improve efficiency.
#' Instead of fitting every frequency it fits groups of frequencies
#' The goal is to lump many high frequency signals to increase signal to
#' noise ratios, and only few low frequency signals to keep resolution at low
#' frequency.
#'
#' @inheritParams make_groups
#' @inheritParams fill_lower_left
#'
#'
#' @return the transfer functions.
#'
#' @noRd
#'
solve_cplx_irr <- function(x, n_groups) {
    .Call(`_hydrorecipes_solve_cplx_irr`, x, n_groups)
}

#' @title
#' ordinary_coherence_phase
#'
#' @description
#' Calculate ordinary coherence and phase from a pgram. Reference:
#' https://vru.vibrationresearch.com/lesson/coherence-mathematics/
#'
#' @param x periodogram matrix (complex matrix)
#'
#' @return Matrix with ordinary coherence and phase.
#'
#' @noRd
#'
ordinary_coherence_phase <- function(x) {
    .Call(`_hydrorecipes_ordinary_coherence_phase`, x)
}

#' @title
#' frequency_to_time_domain
#'
#' @description
#' Convert from frequency to time domain
#'
#' @param pgram. (complex matrix)
#' @param n_groups the frequency response functions. (numeric vector)
#' @param knots knot positions for cubic spline interpolation. (numeric vector)
#'
#'
#' @return the time domain cumulative impulse response.
#'
#' @noRd
#'
frequency_to_time_domain <- function(pgram, n_groups) {
    .Call(`_hydrorecipes_frequency_to_time_domain`, pgram, n_groups)
}

#' @title
#' interpolate_tf
#'
#' @description
#' Go from irregularly spaced frequency response function to a regularly
#' spaced version.  This function will smooth out local variability depending
#' on the chosen knots.
#'
#' @inheritParams which_indices
#'
#' @param x the frequencies. (numeric vector)
#' @param y the frequency response function values. (complex matrix)
#' @param knots locations used to interpolate the frequency response. (numeric vector)
#' @param degree the degree for the \code{b_spline} function. (integer)
#' @param x_interp the frequencies for interpolation. (numeric vector)
#'
#'
#'
#' @return the time domain cumulative impulse response.
#'
#' @noRd
#'
interpolate_tf <- function(x, frequency_irregular, frequency_regular, knots) {
    .Call(`_hydrorecipes_interpolate_tf`, x, frequency_irregular, frequency_regular, knots)
}

#' @title
#' transfer_pgram_smooth
#'
#' @description
#' Calculate the transfer function from an input matrix. This function uses
#' irregular sized groups using `make_groups`. This is experimental to see if
#' and designed to be relatively fast. Instead of fitting every frequency and
#' aggregating post solving, it fits groups of frequencies.
#' The goal is to lump many high frequency signals to increase signal to
#' noise ratios, and only few low frequency signals to keep resolution at low
#' frequency.
#'
#' @inheritParams spec.pgram
#' @inheritParams make_groups
#' @param n_col number of covariate columns (integer)
#'
#'
#' @return the transfer functions.
#'
#' @noRd
#'
transfer_pgram_smooth <- function(x, spans, detrend, demean, taper, power, n_groups) {
    .Call(`_hydrorecipes_transfer_pgram_smooth`, x, spans, detrend, demean, taper, power, n_groups)
}

transfer_pgram <- function(x, spans, detrend, demean, taper) {
    .Call(`_hydrorecipes_transfer_pgram`, x, spans, detrend, demean, taper)
}

#' @title
#' transfer_welch
#'
#' @description
#' Calculate the transfer function from an input matrix. This function uses
#' irregular sized groups using `make_groups`. This is experimental to see if
#' and designed to be relatively fast. Instead of fitting every frequency and
#' aggregating post solving, it fits groups of frequencies.
#' The goal is to lump many high frequency signals to increase signal to
#' noise ratios, and only few low frequency signals to keep resolution at low
#' frequency.
#'
#' @inheritParams spec.pgram
#' @inheritParams make_groups
#' @param n_col number of covariate columns (integer)
#'
#'
#' @return the transfer functions.
#'
#' @noRd
#'
transfer_welch <- function(x, length_subset, overlap, window) {
    .Call(`_hydrorecipes_transfer_welch`, x, length_subset, overlap, window)
}

#' @title
#' predict_pgram_frf
#'
#' @description
#' Calculate the transfer function from an input matrix. This function uses
#' irregular sized groups using `make_groups`. This is experimental to see if
#' and designed to be relatively fast. Instead of fitting every frequency and
#' aggregating post solving, it fits groups of frequencies.
#' The goal is to lump many high frequency signals to increase signal to
#' noise ratios, and only few low frequency signals to keep resolution at low
#' frequency.
#'
#' @inheritParams spec.pgram
#' @inheritParams make_groups
#' @param n_col number of covariate columns (integer)
#'
#'
#' @return the transfer functions.
#'
#' @noRd
#'
predict_pgram_frf <- function(x, x_out, spans, n_groups) {
    .Call(`_hydrorecipes_predict_pgram_frf`, x, x_out, spans, n_groups)
}

#' @title
#' index_from_i_j
#'
#' @description
#' Get the column number for the cross-spectra matrix.
#'
#' @param i row number (integer)
#' @param i column number (integer)
#' @param n_col the number of columns i.e. the number of covariates. (integer)
#'
#' @return integer value containing the column number of the cross-spectra.
#'
#' @noRd
#'
index_from_i_j <- function(i, j, n_col) {
    .Call(`_hydrorecipes_index_from_i_j`, i, j, n_col)
}

get_column_number <- function(n) {
    .Call(`_hydrorecipes_get_column_number`, n)
}

#' @title
#' index_from_j_i
#'
#' @description
#' Get the column number for the cross-spectra matrix.
#'
#' @inheritParams index_from_i_j
#'
#' @return integer value containing the column number of the cross-spectra
#' conjugate term.
#'
#' @noRd
#'
index_from_j_i <- function(i, j, n_col) {
    .Call(`_hydrorecipes_index_from_j_i`, i, j, n_col)
}

#' @title
#' next_n_eigen
#'
#' @description
#' Get the size of the nearest fast length for an FFT. This just uses the base
#' function right now.
#'
#' @inheritParams nextn
#'
#' @return 'nice' integer value for the length of the padded FFT.
#'
#' @noRd
#'
next_n_eigen <- function(n) {
    .Call(`_hydrorecipes_next_n_eigen`, n)
}

#' @title
#' pad_vector
#'
#' @description
#' Pad a vector with zeros to a desired length.
#'
#' @param x initial vector to pad (numeric vector)
#' @param x_old initial length of vector (integer)
#' @param x_new desired length of padded vector (integer)
#'
#' @return 'nice' integer value for the length of the padded FFT.
#'
#' @noRd
#'
pad_vector <- function(x, n_old, n_new) {
    .Call(`_hydrorecipes_pad_vector`, x, n_old, n_new)
}

#' @title
#' detrend_matrix
#'
#' @description
#' Linearly detrend the columns of a matrix. This is translated from spec.pgram
#'
#' @param x the matrix that holds multiple series (numeric matrix)
#'
#' @return columns of a matrix that have been linearly detrended.
#'
#' @noRd
#'
detrend_matrix <- function(x) {
    .Call(`_hydrorecipes_detrend_matrix`, x)
}

#' @title
#' demean_matrix
#'
#' @description
#' Remove the mean from each column of a matrix.
#'
#' @inheritParams detrend_matrix
#'
#' @return columns of a matrix with the means removed.
#'
#' @noRd
#'
demean_matrix <- function(x) {
    .Call(`_hydrorecipes_demean_matrix`, x)
}

#' @title
#' detrend_and_demean_matrix
#'
#' @description
#' Remove the trend and mean from each column of a matrix.
#'
#' @inheritParams detrend_matrix
#' @param detrend should the trend be removed from each column (boolean)
#' @param demean should the mean be removed from each column (boolean)
#'
#' @return columns of a matrix with the means and/or trends removed.
#'
#' @noRd
#'
detrend_and_demean_matrix <- function(x, detrend, demean) {
    .Call(`_hydrorecipes_detrend_and_demean_matrix`, x, detrend, demean)
}

#' @title
#' modified_daniell
#'
#' @description
#' Create a modified daniell kernel using FFT. Adapted from `spec.pgram`.
#'
#' @inheritParams spec.pgram
#'
#' @param n length of the kernel (integer)
#'
#' @return modified Daniell kernel.
#'
#' @noRd
#'
modified_daniell <- function(spans) {
    .Call(`_hydrorecipes_modified_daniell`, spans)
}

#' @title
#' kernel_apply
#'
#' @description
#' Create a modified daniell kernel using FFT. Adapted from `spec.pgram`. This
#' only calculates the upper triangle when truncated is FALSE.  When truncated
#' is TRUE the first row is skipped.
#'
#' @inheritParams spec.pgram
#'
#'
#' @return modified Daniell kernel.
#'
#' @noRd
#'
kernel_apply <- function(x, y) {
    .Call(`_hydrorecipes_kernel_apply`, x, y)
}

#' @title
#' spec_taper
#'
#' @description
#' Create a cosine-bell taper. Adapted from `spec.taper`.
#'
#' @inheritParams spec.taper
#'
#'
#' @return cosine-bell taper.
#'
#' @noRd
#'
spec_taper <- function(n_row, p) {
    .Call(`_hydrorecipes_spec_taper`, n_row, p)
}

#' @title
#' make_groups
#'
#' @description
#' Create a set of lengths with increasing sizes useful from grouping results.
#' The first and last groups have length equal to 1.
#'
#' @param n the number of values to subset into groups. (integer)
#' @param max_lag how fast groups get bigger. Larger numbers have a larger range
#' of group sizes. (integer)
#' @param n_groups the number of groups to create. (integer)
#' @param min_aggregate the minimum size for a group. (integer)
#'
#'
#' @return Matrix with filled in complex conjugate columns.
#'
#' @noRd
#'
make_groups <- function(n_groups, n) {
    .Call(`_hydrorecipes_make_groups`, n_groups, n)
}

#' @title
#' power_spaced
#'
#' @description
#' Create an n length vector of power spaced series between min and max.
#'
#' @param n the number of values. (integer)
#' @param min minimum value in series. (integer)
#' @param max maximum value in series. (integer)
#' @param power how fast values change. (integer)
#'
#'
#' @return vector of power spaced series between min and max.
#'
#' @noRd
#'
power_spaced <- function(n, min, max, power) {
    .Call(`_hydrorecipes_power_spaced`, n, min, max, power)
}

#' @title
#' group_frequency
#'
#' @description
#' Get the mean frequency for each group.
#'
#' @inheritParams make_groups
#'
#' @param frequency vector of frequencies. (integer)
#'
#'
#' @return vector frequencies for each group.
#'
#' @noRd
#'
group_frequency <- function(frequencies, n_groups) {
    .Call(`_hydrorecipes_group_frequency`, frequencies, n_groups)
}

#' @title
#' determine_frequency
#'
#' @description
#' Get frequencies based on series length
#'
#'
#' @param n length of series. (integer)
#'
#'
#' @return vector of frequencies between 0 and 0.5.
#'
#' @noRd
#'
determine_frequency <- function(n) {
    .Call(`_hydrorecipes_determine_frequency`, n)
}

check_ffts <- function(x, cutoff) {
    .Call(`_hydrorecipes_check_ffts`, x, cutoff)
}

#' @title
#' which_indices
#'
#' @description
#' Determine the intervals that each x value falls in
#'
#' @inheritParams splines::bs
#' @param knots location of knots for the b-splines. Unlike `splines::bs` this
#' includes the boundary knots. (numeric vector)
#'
#'
#' @return the interval ids that each x value falls in.
#'
#' @noRd
#'
which_indices <- function(x, knots) {
    .Call(`_hydrorecipes_which_indices`, x, knots)
}

#' @title
#' window_hann
#'
#' @description
#' Hann window for FFT.
#'
#' @param n length of the window vector (integer)
#'
#' @return window of length n.
#'
#' @noRd
#'
window_hann <- function(n) {
    .Call(`_hydrorecipes_window_hann`, n)
}

#' @title
#' window_tukey
#'
#' @description
#' Tukey window for FFT.
#'
#' @inheritParams window_hann
#' @param r percent on each side to taper (double)
#'
#' @return window of length n.
#'
#' @noRd
#'
window_tukey <- function(n, r) {
    .Call(`_hydrorecipes_window_tukey`, n, r)
}

#' @title
#' window_hann_cplx
#'
#' @description
#' Hann window for complex FFT.
#'
#' @inheritParams window_hann
#'
#' @return window of length n.
#'
#' @noRd
#'
window_hann_cplx <- function(n) {
    .Call(`_hydrorecipes_window_hann_cplx`, n)
}

#' @title
#' window_rectangle
#'
#' @description
#' Rectangular window.
#'
#' @inheritParams window_hann
#'
#' @return window of length n.
#'
#' @noRd
#'
window_rectangle <- function(n) {
    .Call(`_hydrorecipes_window_rectangle`, n)
}

#' @title
#' window_first_deriv
#'
#' @description
#' First derivative window for FFT
#'
#' @inheritParams window_hann
#'
#' @param a0 \code{double} coefficient
#' @param a1 \code{double} coefficient
#' @param a2 \code{double} coefficient
#' @param a3 \code{double} coefficient
#'
#' @return window
#'
#' @export
#'
#' @examples
#' # nuttall window
#' window_first_deriv(100, 0.355768, 0.487396, 0.144232, 0.012604)
#'
#' @noRd
#'
window_first_deriv <- function(n, a0, a1, a2, a3) {
    .Call(`_hydrorecipes_window_first_deriv`, n, a0, a1, a2, a3)
}

#' @title
#' window_nuttall
#'
#' @description
#' Nuttall window for FFT
#'
#' @inheritParams window_hann
#'
#' @return window
#'
#' @export
#'
#' @examples
#' window_nuttall(100)
#'
#' @noRd
#'
window_nuttall <- function(n) {
    .Call(`_hydrorecipes_window_nuttall`, n)
}

#' @title
#' window_blackman_nuttall
#'
#' @description
#' Blackman-Nuttall window for FFT
#'
#' @inheritParams window_hann
#'
#' @return window
#'
#' @export
#'
#' @examples
#' window_blackman_nuttall(100)
#'
#' @noRd
#'
window_blackman_nuttall <- function(n) {
    .Call(`_hydrorecipes_window_blackman_nuttall`, n)
}

#' @title
#' window_blackman_harris
#'
#' @description
#' Blackman-Harris window for FFT
#'
#' @inheritParams window_hann
#'
#' @return window
#'
#' @export
#'
#' @examples
#' window_blackman_harris(100)
#'
#' @noRd
#'
window_blackman_harris <- function(n) {
    .Call(`_hydrorecipes_window_blackman_harris`, n)
}

#' @title
#' window_scale
#'
#' @description
#' Scale factor for a window function.
#'
#' @param window the window function (numeric vector)
#' @param n_new length of the padded series (integer)
#' @param n_fft length of the input series (integer)
#'
#' @return window of length n.
#'
#' @noRd
#'
window_scale <- function(window, n_new, n_fft) {
    .Call(`_hydrorecipes_window_scale`, window, n_new, n_fft)
}

#' @title
#' harmonic_double
#'
#' @description
#' This function creates a matrix of sin and cosine curves at specified
#' frequencies with a defined cycle size.
#'
#' @inheritParams step_harmonic
#' @param x the sample spacings (numeric vector)
#' @param frequency frequencies of the sin and cosine curves (numeric vector)
#' @param cycle_size the cycle size in terms of x (numeric)
#'
#' @return matrix of sin and cosine curves.  The sin curves are the first set
#' of columns and the cosine curves are the second set.
#'
#' @noRd
#'
harmonic_double <- function(x, frequency, cycle_size) {
    .Call(`_hydrorecipes_harmonic_double`, x, frequency, cycle_size)
}

#' @title
#' impulse_function
#'
#' @description
#' Calculation of the impulse function from a well function.
#'
#' @param u well function
#' @param flow_time_interval time between flow rate measurements in samples
#'
#' @return impulse function for convolution
#'
#'
#' @export
#'
impulse_function <- function(u, flow_time_interval) {
    .Call(`_hydrorecipes_impulse_function`, u, flow_time_interval)
}

log_lags_eigen <- function(n, max_lag) {
    .Call(`_hydrorecipes_log_lags_eigen`, n, max_lag)
}

check_lag <- function(n, lag, n_shift) {
    .Call(`_hydrorecipes_check_lag`, n, lag, n_shift)
}

get_length <- function(n, n_subset) {
    .Call(`_hydrorecipes_get_length`, n, n_subset)
}

get_start <- function(n_out, lag, n_subset) {
    .Call(`_hydrorecipes_get_start`, n_out, lag, n_subset)
}

get_end <- function(n, n_out, lag, n_subset) {
    .Call(`_hydrorecipes_get_end`, n, n_out, lag, n_subset)
}

#' @title
#' shift_subset
#'
#' @description
#' lag data and subset the results
#'
#' @inheritParams step_lead_lag
#' @param x to lag (numeric vector)
#' @param lag amount to lag or lead if negative (integer)
#'
#' @return vector with lagged values
#'
#' @noRd
#'
shift_subset <- function(x, lag, n_subset, n_shift) {
    .Call(`_hydrorecipes_shift_subset`, x, lag, n_subset, n_shift)
}

#' @title
#' lag_matrix
#'
#' @description
#' Lag data and subset the results.  Each column of \code(x) will be lagged.
#'
#' @inheritParams step_lead_lag
#' @param x to lag (numeric vector)
#' @param lags lead or lag values (numeric vector)
#'
#' @return matrix with lagged values
#'
#' @noRd
lag_matrix <- function(x, lags, suffix, prefix, n_subset, n_shift) {
    .Call(`_hydrorecipes_lag_matrix`, x, lags, suffix, prefix, n_subset, n_shift)
}

#' @title
#' distributed_lag_parallel
#'
#' @description
#' This method calculates the basis for a distributed lag in parallel.  It is currently
#' slow.
#'
#' @inheritParams step_lead_lag
#' @param x values to lag (numeric vector)
#' @param bl the basis lags (numeric matrix)
#' @param lag_max maximum number of lags (integer)
#'
#' @return distributed lag basis
#'
#' @noRd
#'
distributed_lag_parallel <- function(x, bl, lag_max, n_subset, n_shift) {
    .Call(`_hydrorecipes_distributed_lag_parallel`, x, bl, lag_max, n_subset, n_shift)
}

to_dummy <- function(x, n_fact) {
    .Call(`_hydrorecipes_to_dummy`, x, n_fact)
}

#' @title
#' well_function_coefficient
#'
#' @description
#' Calculation Coefficient Q/(4 pi * T)
#'
#' @param flow_rate well flow rates
#' @param transmissivity aquifer transmissivity
#'
#' @return coefficient for Theis and Hantush well function
#'
#'
#' @export
#'
well_function_coefficient <- function(flow_rate, transmissivity) {
    .Call(`_hydrorecipes_well_function_coefficient`, flow_rate, transmissivity)
}

#' @title
#' grf_coefficient
#'
#' @description
#' Coefficient for the grf without pumping
#'
#' @param flow_rate (vector) the flow rate
#' @param radius (double) distance to center of source
#' @param K (double) hydraulic conductivity of the fracture system
#' @param thickness (double) thickness
#' @param flow_dimension (double) flow dimension
#'
#' @return coefficient
#'
#'
#' @export
#'
grf_coefficient <- function(flow_rate, radius, K, thickness, flow_dimension) {
    .Call(`_hydrorecipes_grf_coefficient`, flow_rate, radius, K, thickness, flow_dimension)
}

#' @title
#' hantush_epsilon
#'
#' @description
#' Calculation of r^2/(4B^2)
#'
#' @param radius distance to monitoring well
#' @param leakage aquifer transmissivity
#'
#' @return coefficient Hantush well function
#'
#'
#' @export
#'
hantush_epsilon <- function(radius, leakage) {
    .Call(`_hydrorecipes_hantush_epsilon`, radius, leakage)
}

#' @title
#' grf_u_time
#'
#' @description
#' Calculation of grf u
#'
#' @param radius distance to monitoring interval
#' @param storativity aquifer storativity
#' @param K aquifer hydraulic conductivity
#' @param time prediction times
#'
#' @return u for well function
#'
#'
#' @export
#'
grf_u <- function(radius, storativity, K, time) {
    .Call(`_hydrorecipes_grf_u`, radius, storativity, K, time)
}

