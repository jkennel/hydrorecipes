---
title: "FFT methods in hydrorecipes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FFT methods in hydrorecipes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hydrorecipes)
```

```{r pgram}
data("transducer")

# wl_ba_et <- as.matrix(transducer[, -1])
# n <- 35000
# sp_w <- spec_welch(
#   x = wl_ba_et,
#   length_subset = n,
#   overlap = 0.995,
#   window = window_hann(n)
# )

# sp_p <- spec_pgram(
#   x = wl_ba_et[1:n, ],
#   spans = 3,
#   detrend = TRUE,
#   demean = TRUE,
#   taper = 0.1
# )
```

```{r transfer}
# tf_p <- solve_cplx_parallel(sp_p)
# tf_w <- solve_cplx_parallel(sp_w)
# tf_p <- solve_cplx_irr(sp_p, 50)
# tf_w <- solve_cplx_irr(sp_w, 50)

# plot(Mod(tf_w[, 1]), type = "h", ylim = c(0, 1))
# plot(Mod(tf_p[, 1]), type = "h", ylim = c(0, 1))
```


Steps:
- Estimate the periodogram
- Calculate the transfer function for logarthmically spaced intervals
- Interpolate a smooth transfer function back to original frequencies (cubic b-splines)
- Do the inverse FFT to get the time domain response


```{r frftobrf}
# a <- frequency_to_time_domain(sp_w, 100)
# plot(cumsum(a[, 1]) ~ seq(1, nrow(a) * 120, by = 120),
#   type = "l", log = "x", ylim = c(0, 1)
# )


# transducer$datetime <- as.numeric(transducer$datetime)
# rec <- recipe(wl ~ baro + et + datetime, transducer) |>
#   step_distributed_lag(baro,
#     knots = log_lags(20, 86400 * 2 / 120)
#   ) |>
#   step_lead_lag(et, lag = seq(0, 120, 15)) |>
#   step_bs(datetime, deg_free = 8) |>
#   prep()

# sub1 <- rec |>
#   bake(new_data = NULL)

# fit <- lm(wl ~ ., sub1)
# resp <- response(fit, rec)
# resp$x <- resp$x * 120
# points(value ~ x, resp[resp$name == "cumulative" & resp$term == "baro", ],
#   type = "l", col = "red"
# )
```


```{r predict}
```
